/* -*- mode: javascript; tab-width: 4; indent-tabs-mode: nil -*- */
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is [Open Source Virtual Machine.].
 *
 * The Initial Developer of the Original Code is Art Compiler
 *
 * Portions created by the Initial Developer are Copyright (C) 2012
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Jeff Dyer, Art Compiler
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

use namespace Parse

class Analyzer extends Visitor {

    const xFactor = 7
    const yFactor = 10

    var root

    function Analyzer(root)
        : root = root
    {
        table = {
            "Head" : head,
            "Fixture" : fixture,
            "ClassFixture" : stub,
            "MethodFixture" : methodFixture,
            "ValFixture" : valFixture,
            "VirtualValFixture" : stub,
            "ModuleFixture" : stub,
            "InitBinding" : initBinding,
            "ObjectPattern" : stub,
            "FieldPattern" : stub,
            "ArrayPattern" : stub,
            "SimplePattern" : stub,
            "IdentifierPattern" : stub,
            "Name" : name,
            "TernaryExpr" : stub,
            "BinaryExpr" : binaryExpr,
            "UnaryExpr" : unaryExpr,
            "ThisExpr" : thisExpr,
            "YieldExpr" : stub,
            "SuperExpr" : stub,
            "CallExpr" : callExpr,
            "NewExpr" : newExpr,
            "ObjectRef" : objectRef,
            "ComputedName" : computedName,
            "SetExpr" : setExpr,
            "EvalScopeInitExpr" : stub,
            "ComprehendIf" : comprehendIf,
            "ComprehendFor" : comprehendFor,
            "InitExpr" : initExpr,
            "Identifier" : identifier,
            "LiteralNull" : literalNull,
            "LiteralUndefined" : literalUndefined,
            "LiteralDouble" : stub,
            "LiteralInt" : literalInt,
            "LiteralUInt" : stub,
            "LiteralBoolean" : literalBoolean,
            "LiteralString" : literalString,
            "LiteralArray" : literalArray,
            "LiteralComprehension" : arrayComprehension,
            "LiteralObject" : literalObject,
            "LiteralField" : literalField,
            "VirtualField" : virtualField,
            "LiteralFunction" : literalFunction,
            "LiteralRegExp" : stub,
            "Cls" : stub,
            "Func" : func,
            "FuncName" : funcName,
            "FuncAttr" : stub,
            "Ctor" : stub,
            "ParamInit" : stub,
            "EmptyStmt" : stub,
            "ExprStmt" : exprStmt,
            "ReturnStmt" : returnStmt,
            "ThrowStmt" : throwStmt,
            "BreakStmt" : breakStmt,
            "ContinueStmt" : continueStmt,
            "ForStmt" : forStmt,
            "ForBindingStmt" : forBindingStmt,
            "ForInStmt" : stub,
            "ForInBindingStmt" : forInBindingStmt,
            "IfStmt" : ifStmt,
            "SwitchStmt" : stub,
            "DoWhileStmt" : doWhileStmt,
            "WhileStmt" : whileStmt,
            "BlockStmt" : blockStmt,
            "Block" : block,
            "Case" : stub,
            "WithStmt" : stub,
            "TryStmt" : stub,
            "Catch" : stub,
            "Program" : program,
            "Module" : stub,
            "Import" : stub,
            "Export" : stub,
            "LetExpr" : letExpr,
            "TempName" : tempName,
            "GetTemp" : getTemp,
            "GetCogenTemp" : getCogenTemp,
            "GetParam" : getParam
        }
    }

    function analyze() {
        let topFixtures = []  // put builtins here
        let cx = new Definer(null, topFixtures)
        return visit(cx, root)
    }

    // BEGIN VISITOR METHODS

    function program(cx, node) {
        print("program")
        cx.enterGlobal()
        node.head = visit(cx, node.head)
        node.body = visit(cx, node.body)
        cx.exitGlobal()
        return node
    }

    function exprStmt(cx, node) {
        print("exprStmt")
        node.expr = visit(cx, node.expr)
        return node
    }

    function returnStmt(cx, node) {
        print("returnStmt")
        visit(cx, node.expr)
        return node
    }

    function throwStmt(cx, node) {
        print("throwStmt")
        let startCol = col
        let startLn = ln
        let elts = [ ]
        elts.push({
            "tag": "tspan",
            "class": "keyword",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": (col += "throw ".length),
            "stopLn": ln,
            "elts": ["throw"]
        })
        elts.push(visit(cx, node.expr))
        ln += 1
        col = indent()
        return node
        return {
            "tag": "tspan",
            "class": "ThrowStmt",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        } 
    }

    function continueStmt(cx, node) {
        print("continueStmt")
        let startCol = col
        let startLn = ln
        let elts = [ ]
        elts.push({
            "tag": "tspan",
            "class": "keyword",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["continue"]
        })
        if (cx, node.ident) {
            col += "continue ".length
            elts.push(visit(cx, node.ident))
        }
        ln++
        col = indent()
        return node
        return {
            "tag": "tspan",
            "class": "ContinueStmt",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        } 
    }

    function breakStmt(cx, node) {
        print("breakStmt")
        let startCol = col
        let startLn = ln
        let elts = [ ]
        elts.push({
            "tag": "tspan",
            "class": "keyword",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["break"]
        })
        if (cx, node.ident) {
            col += "break".length
            elts.push(visit(cx, node.ident))
        }
        ln++
        col = indent()
        return node
        return {
            "tag": "tspan",
            "class": "BreakStmt",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        } 
    }

    function letExpr(cx, node) {
        print("letExpr")
        let startCol = col
        let startLn = ln
        let elts = [ ]
        elts.push(visit(cx, node.head))
        ln += 1
        col = indent()
        elts.push(visit(cx, node.expr))
        ln += 1
        col = indent()
        return node
        return {
            "tag": "tspan",
            "class": "LetExpr",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        } 
    }

    function blockStmt(cx, node) {
        print("blockStmt")
        let startCol = col
        let startLn = ln
        let elts = [ ]
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["{"]
        })
        ln += 1
        col = indent(+1)
        elts.push(visit(cx, node.block))
        col = indent(-1)
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["}"]
        })
        return node
        return {
            "tag": "tspan",
            "class": "BlockStmt",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        }
    }

    function block(cx, node) {
        print("block")
        let startCol = col
        let startLn = ln
        let elts = [ ]
        elts.push(visit(cx, node.head))
        elts.push(visit(cx, node.stmts))
        return node
        return { 
            "tag": "tspan",
            "class": "Block",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        } 
    }

    function ifStmt(cx, node) {
        print("ifStmt")
        let startCol = col
        let startLn = ln
        let startCol = col
        let startLn = ln
        let elts = [ ]
        elts.push({
            "tag": "tspan",
            "class": "keyword",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["if"]
        })
        col += ("if ").length
        elts.push(visit(cx, node.test))
        col++
        if (cx, node.consequent.tag !== "BlockStmt") {
            elts.push({
                "tag": "tspan",
                "class": "punc",
                "id": node.id,
                "startCol": col,
                "startLn": ln,
                "stopCol": col,
                "stopLn": ln,
                "elts": ["{"]
            })
            ln++
            col = indent(+1)
        }
        elts.push(visit(cx, node.consequent))
        if (cx, node.consequent.tag !== "BlockStmt") {
            ln++
            col = indent(-1)
            elts.push({
                "tag": "tspan",
                "class": "punc",
                "id": node.id,
                "startCol": col,
                "startLn": ln,
                "stopCol": col,
                "stopLn": ln,
                "elts": ["}"]
            })
        }
        ln++
        if (cx, node.alternate) {
            elts.push({
                "tag": "tspan",
                "class": "keyword",
                "id": node.id,
                "startCol": col,
                "startLn": ln,
                "stopCol": col,
                "stopLn": ln,
                "elts": ["else"]
            })
            col += ("else ").length
            if (cx, node.alternate.tag !== "BlockStmt") {
                col++
                elts.push({
                    "tag": "tspan",
                    "class": "punc",
                    "id": node.id,
                    "startCol": col,
                    "startLn": ln,
                    "stopCol": col,
                    "stopLn": ln,
                    "elts": ["{"]
                })
                ln++
                col = indent(+1)
            }
            elts.push(visit(cx, node.alternate))
            if (cx, node.alternate.tag !== "BlockStmt") {
                ln++
                col = indent(-1)
                elts.push({
                    "tag": "tspan",
                    "class": "punc",
                    "id": node.id,
                    "startCol": col,
                    "startLn": ln,
                    "stopCol": col,
                    "stopLn": ln,
                    "elts": ["}"]
                })
            }
            ln++
        }
        return node
        return {
            "tag": "tspan",
            "class": "IfStmt",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        }
    }

    function whileStmt(cx, node) {
        print("whileStmt")
        let startCol = col
        let startLn = ln
        let elts = [ ]
        elts.push({
            "tag": "tspan",
            "class": "keyword",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["while"]
        })
        col += ("while ").length
        elts.push(visit(cx, node.expr))
        col++
        if (cx, node.stmt.tag !== "BlockStmt") {
            elts.push({
                "tag": "tspan",
                "class": "punc",
                "id": node.id,
                "startCol": col,
                "startLn": ln,
                "stopCol": col,
                "stopLn": ln,
                "elts": ["{"]
            })
            ln++
            col = indent(+1)
        }
        elts.push(visit(cx, node.stmt))
        if (cx, node.stmt.tag !== "BlockStmt") {
            ln++
            col = indent(-1)
            elts.push({
                "tag": "tspan",
                "class": "punc",
                "id": node.id,
                "startCol": col,
                "startLn": ln,
                "stopCol": col,
                "stopLn": ln,
                "elts": ["}"]
            })
        }
        ln += 1
        return node
        return {
            "tag": "tspan",
            "class": "WhileStmt",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        } 
    }

    function doWhileStmt(cx, node) {
        print("doWhileStmt")
        let startCol = col
        let startLn = ln
        let elts = [ ]
        elts.push({
            "tag": "tspan",
            "class": "keyword",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["do"]
        })
        col += ("do ").length
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["{"]
        })
        ln += 1
        col = indent(+1)
        elts.push(visit(cx, node.stmt))
        ln += 1
        col = indent(-1)
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["}"]
        })
        ln += 1
        elts.push({
            "tag": "tspan",
            "class": "keyword",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["while"]
        })
        col += ("while ").length
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["("]
        })
        col += ("(").length
        elts.push(visit(cx, node.expr))
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": [")"]
        })
        ln += 1
        col = indent()
        return node
        return {
            "tag": "tspan",
            "class": "DoWhileStmt",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        } 
    }

    function forStmt(cx, node) {
        print("forStmt")
        let startCol = col
        let startLn = ln
        let elts = [ ]
        elts.push({
            "tag": "tspan",
            "class": "keyword",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["for"]
        })
        col += ("for ").length
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["("]
        })
        col += ("(").length
        let tempCol = col
        elts.push(visit(cx, node.init))
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": [";"]
        })
        col += ("; ").length
        ln++
        col = tempCol
        elts.push(visit(cx, node.cond))
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": [";"]
        })
        col += ("; ").length
        ln++
        col = tempCol
        elts.push(visit(cx, node.incr))
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": [")"]
        })
        col += ") ".length
        if (cx, node.stmt.tag !== "BlockStmt") {
            elts.push({
                "tag": "tspan",
                "class": "punc",
                "id": node.id,
                "startCol": col,
                "startLn": ln,
                "stopCol": col,
                "stopLn": ln,
                "elts": ["{"]
            })
            ln++
            col = indent(+1)
        }
        elts.push(visit(cx, node.stmt))
        if (cx, node.stmt.tag !== "BlockStmt") {
            ln++
            col = indent(-1)
            elts.push({
                "tag": "tspan",
                "class": "punc",
                "id": node.id,
                "startCol": col,
                "startLn": ln,
                "stopCol": col,
                "stopLn": ln,
                "elts": ["}"]
            })
        }
        ln += 1
        return node
        return {
            "tag": "tspan",
            "class": "ForStmt",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        } 
    }

    function forBindingStmt(cx, node) {
        print("forBindingStmt")
        let startCol = col
        let startLn = ln
        let elts = [ ]
        elts.push({
            "tag": "tspan",
            "class": "keyword",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["for"]
        })
        col += ("for ").length
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["("]
        })
        col += ("(").length
        elts.push(visit(cx, node.init))
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": [";"]
        })
        col += ("; ").length
        elts.push(visit(cx, node.cond))
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": [";"]
        })
        col += ("; ").length
        elts.push(visit(cx, node.incr))
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": [")"]
        })
        elts.push(visit(cx, node.stmt))
        return node
        return {
            "tag": "tspan",
            "class": "ForBindingStmt",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        } 
    }

    function setExpr(cx, node) {
        print("setExpr")
        let fx = cx.findFixtureWithNames(node.le.ident, new Ast::NamespaceSet(Ast::publicNS), null)
        // point to the fixture and fixture to here
        if (fx) {
            node.write = [fx.data.id]
            if (fx.data.defs === void 0) {
                fx.data.defs = [ ]
            }
            fx.data.defs.push(node.id)
        }
        return node
    }

    function forInBindingStmt(cx, node) {
        print("forInBindingStmt")
        let startCol = col
        let startLn = ln
        let elts = [ ]

        elts.push({
            "tag": "tspan",
            "class": "keyword",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["for"]
        })
        col += ("for ").length
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["("]
        })
        col += ("(").length
        elts.push(visit(cx, node.head))
        elts.push(visit(cx, node.assignment.inits[0].name))   // FIXME hide details behind function abstraction
        col += 1
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["in"]
        })
        col += ("in ").length
        elts.push(visit(cx, node.obj))
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": [")"]
        })
        ln += 1
        col = indent()
        elts.push(visit(cx, node.stmt))
        ln += 1
        col = indent()
        ln += 1
        return node
        return { 
            "tag": "tspan",
            "class": "ForInBindingStmt",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        }
    }

    function initExpr(cx, node) {
        print("initExpr")
        let startCol = col
        let startLn = ln
        let elts = [ ]
        elts.push(visit(cx, node.head))
        elts.push(visit(cx, node.inits))
        return node
        return { 
            "tag": "tspan",
            "class": "InitExpr",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        }
    }

    function initBinding(cx, node) {
        print("initBinding")
        let fx = cx.findFixtureWithNames(node.name.ident, new Ast::NamespaceSet(Ast::publicNS), null)
        // point to the fixture and fixture to here
        node.write = [fx.data.id]
        if (fx.data.defs === void 0) {
            fx.data.defs = [ ]
        }
        fx.data.defs.push(node.id)
        visit(cx, node.expr)
        return node
    }

    function newExpr(cx, node) {
        return callExpr(cx, node, true)
    }

    function callExpr(cx, node, isNew=false) {
        print("callExpr")
        let startCol = col
        let startLn = ln
        let elts = [ ]
        if (isNew) {
            elts.push({
                "tag": "tspan",
                "class": "keyword",
                "id": node.id,
                "startCol": col,
                "startLn": ln,
                "stopCol": col+="new ".length,
                "stopLn": ln,
                "elts": ["new"]
            })
        }            
        elts.push(visit(cx, node.expr))
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col += ("(").length,
            "stopLn": ln,
            "elts": ["("]
        })
        
        //elts.push(visit(cx, node.args))
        if (cx, node.args.length > 0) {
            indent(+1)
            for (let i = 0; i < node.args.length; i++) {
                if (cx, node.args.length > 1) {
                    ln++
                    col = indent()
                }
                elts.push(visit(cx, node.args[i]))
                if (i < node.args.length-1) {
                    elts.push({
                        "tag": "tspan",
                        "class": "punc",
                        "id": node.id,
                        "startCol": col,
                        "startLn": ln,
                        "stopCol": col += ", ".length,
                        "stopLn": ln,
                        "elts": [","]
                    })
                }
            }
            indent(-1)
        }
        //elts.push(visit(cx, node.spread))
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": [")"]
        }) 
        col += (")").length
        let n = {
            "tag": "tspan",
            "class": isNew ? "NewExpr" : "CallExpr",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        }
        return node
    }

    function head(cx, node) {
        print("head")
        let startCol = col
        let startLn = ln
        let elts = [ ]
        elts.push(visit(cx, node.fixtures))
        elts.push(visit(cx, node.exprs))
        return node
        return {
            "tag": "tspan",
            "class": "Head",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        }
    }

    function fixture(cx, node) {
        print("fixture")
        cx.addFixture(Ast::varInit, new Ast::Name(Ast::publicNS, node.name.ident, null), node, false);
        visit(cx, node.data)
        return node
    }

    function name(cx, node) {
        print("name")
        let startCol = col
        let startLn = ln
        let elts = [ ]
        elts.push({
            "tag": "tspan",
            "class": "ident",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": [String(cx, node.ident)]
        })
        col += (String(cx, node.ident)).length
        return node
        return {
            "tag": "tspan",
            "class": "Name",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        }
    }

    function tempName(cx, node) {
        print("tempName")
        let startCol = col
        let startLn = ln
        let elts = [ ]
        elts.push({
            "tag": "tspan",
            "class": "ident",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["$t"+node.index]
        })
        col += ("$t"+node.index).length
        return node
        return {
            "tag": "tspan",
            "class": "TempName",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        }
    }

    function getCogenTemp(cx, node) {
        print("getCogenTemp")
        let startCol = col
        let startLn = ln
        let elts = [ ]
        return node
        return {
            "tag": "tspan",
            "class": "GetCogenTemp",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        }
    }

    function getTemp(cx, node) {
        print("getTemp")
        let startCol = col
        let startLn = ln
        let elts = [ ]
        elts.push({
            "tag": "tspan",
            "class": "ident",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["$t"+node.n]
        })
        col += ("$t"+node.n).length
        return node
        return {
            "tag": "tspan",
            "class": "GetTemp",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        }
    }

    function getParam(cx, node) {
        print("getParam")
        let startCol = col
        let startLn = ln
        let elts = [ ]
        elts.push({
            "tag": "tspan",
            "class": "ident",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": [""+node.n]
        })
        col += (""+node.n).length
        return node
        return {
            "tag": "tspan",
            "class": "GetParam",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        }
    }

    function literalFunction(cx, node) {
        print("literalFunction")
        let startCol = col
        let startLn = ln
        let elts = [ ]
        elts.push({
            "tag": "tspan",
            "class": "keyword",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["function"]
        })
        col += ("function ").length
        elts.push(visit(cx, node.func))
        return node
        return {
            "tag": "tspan",
            "class": "LiteralFunction",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        }
    }

    function methodFixture(cx, node) {
        print("methodFixture")
        let startCol = col
        let startLn = ln
        let elts = [ ]
        elts.push(visit(cx, node.func))
        return node
        return {
            "tag": "tspan",
            "class": "MethodFixture",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        }
    }

    function valFixture(cx, node) {
        print("valFixture")
        let elts = [ ]
        return node
        return {
            "tag": "tspan",
            "class": "ValFixture",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        }
    }

    var ln = 1
    var col = 1

    var level = 1
    const oneIndent = 4

    function indent(delta=0) {
        level += oneIndent * delta
        return level
    }

    function func(cx, node) {
        print("func")
        cx.enterFunction({})
        let startCol = col
        let startLn = ln
        let elts = [ ]
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["("]
        })
        col += "(".length
        if (cx, node.params.fixtures.length==0) {
            // do nothing
            indent(+1)   // to make the -1 below work out
        }
        else
        if (cx, node.params.fixtures.length==1) {
            elts.push(visit(cx, node.params.fixtures[i].name))
            indent(+1)   // to make the -1 below work out
        }
        else {
            ln += 1
            col = indent(+1)
            for (let i = 0; i < node.params.fixtures.length; i++) {
                elts.push(visit(cx, node.params.fixtures[i].name))
                if (i < node.params.fixtures.length-1) {
                    elts.push({
                        "tag": "tspan",
                        "class": "punc",
                        "id": node.id,
                        "startCol": col,
                        "startLn": ln,
                        "stopCol": col,
                        "stopLn": ln,
                        "elts": [","]
                    })
                    col = indent()
                    ln += 1
                }
            }
        }
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": [") {"]
        })
        if (cx, node.vars.length || node.body.length) {
            ln += 1
            col = indent()
            elts.push(visit(cx, node.vars))
            //elts.push(visit(cx, node.attr))
            elts.push(visit(cx, node.body))
        }
        ln += 1
        col = indent(-1)
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["}"]
        })
        col += 1
        cx.exitFunction()
        return node
    }

    function funcName(cx, node) {
        print("funcName")
        let startCol = col
        let startLn = ln
        let elts = [ ]
        switch (cx, node.kind) {
        case 0:
            // nothing to do
            break
        default:
            throw "funcName kind not implemented"
            break
        }
        elts.push(visit(cx, node.ident))
        let n = {
            "tag": "tspan",
            "class": "FuncName",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        }
        col += (cx, node.ident + " ").length
        return n
    }

    function identifier(cx, node) {
        print("identifier")
        let fx = cx.findFixtureWithNames(node.ident, new Ast::NamespaceSet(Ast::publicNS), null)
        // point to the fixture and fixture to here
        if (fx) {
            node.read = [fx.data.id]
            if (fx.data.uses === void 0) {
                fx.data.uses = [ ]
            }
            fx.data.uses.push(node.id)
        }
        return node
    }

    function literalString(cx, node) {
        print("literalString")
        let startCol = col
        let startLn = ln
        let elts = []
        if (cx, node.strValue.charAt(0) === "'") {
            elts.push('"'+node.strValue+'"')
        }
        else {
            elts.push("'"+node.strValue+"'")
        }
        let n = {
            "tag": "tspan",
            "class": "LiteralString",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": (col += (cx, node.strValue + "  ").length),
            "stopLn": ln,
            "elts": elts
        }
        return n        
    }

    function literalUndefined(cx, node) {
        print("literalUndefined")
        let n = {
            "tag": "tspan",
            "class": "LiteralUndefined",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["void 0"]
        }
        col += ("void 0").length
        return n        
    }

    function literalArray(cx, node) {
        print("literalArray")
        let startCol = col
        let startLn = ln
        let elts = [ ]
        let tempCol = col
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["["]
        })
        for (let i = 0; i < node.exprs.length; i++) {
            col = tempCol + 1
            if (cx, node.exprs[i].constructor !== Object || 
                node.exprs[i].tag !== "LiteralUndefined") {
                elts.push(visit(cx, node.exprs[i]))
            }
            if (i < node.exprs.length-1) {
                elts.push({
                    "tag": "tspan",
                    "class": "punc",
                    "id": node.id,
                    "startCol": col,
                    "startLn": ln,
                    "stopCol": col,
                    "stopLn": ln,
                    "elts": [","]
                })
                ln += 1
            }
        }
        if (cx, node.spread) {
            elts.push({
                "tag": "tspan",
                "class": "punc",
                "id": node.id,
                "startCol": col,
                "startLn": ln,
                "stopCol": col,
                "stopLn": ln,
                "elts": ["..."]
            })
            col += ("...").length
            elts.push(visit(cx, node.spread))
            if (cx, node.exprs.length > 0) {
                elts.push({
                    "tag": "tspan",
                    "class": "punc",
                    "id": node.id,
                    "startCol": col,
                    "startLn": ln,
                    "stopCol": col,
                    "stopLn": ln,
                    "elts": [","]
                })
                ln += 1
                col = tempCol
            }
            col = tempCol + 2
        }
        if (cx, node.exprs.length != 0) {
            ln += 1
            col = tempCol
        }
        else {
            col = tempCol + 2
        }
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["]"]
        })
        col += ("]").length
        return node
        return {
            "tag": "tspan",
            "class": "LiteralArray",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        }
    }

    function literalObject(cx, node) {
        print("literalObject")
        let startCol = col
        let startLn = ln
        let elts = [ ]
        let tempCol = col
        if (cx, node.fields.length > 0) {
            elts.push({
                "tag": "tspan",
                "class": "punc",
                "id": node.id,
                "startCol": col,
                "startLn": ln,
                "stopCol": col,
                "stopLn": ln,
                "elts": ["{"]
            })
            indent(+1)
            for (let i = 0; i < node.fields.length; i++) {
                ln += 1
                col = indent()
                elts.push(visit(cx, node.fields[i]))
                if (i < node.fields.length - 1) {
                    elts.push({
                        "tag": "tspan",
                        "class": "punc",
                        "id": node.id,
                        "startCol": col,
                        "startLn": ln,
                        "stopCol": col,
                        "stopLn": ln,
                        "elts": [","]
                    })
                }
            }
            ln += 1
            col = indent(-1)
            elts.push({
                "tag": "tspan",
                "class": "punc",
                "id": node.id,
                "startCol": col,
                "startLn": ln,
                "stopCol": col,
                "stopLn": ln,
                "elts": ["}"]
            })
            col += ("}").length
        }
        else {
            elts.push({
                "tag": "tspan",
                "class": "punc",
                "id": node.id,
                "startCol": col,
                "startLn": ln,
                "stopCol": col,
                "stopLn": ln,
                "elts": ["{ }"]
            })
            col += "{}".length
        }
        return node
        return {
            "tag": "tspan",
            "class": "LiteralObject",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        }
    }

    function literalField(cx, node) {
        print("literalField")
        let startCol = col
        let startLn = ln
        let elts = [ ]
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col += "'".length,
            "stopLn": ln,
            "elts": ["'"]
        })
        elts.push(visit(cx, node.ident))
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col += "'".length,
            "stopLn": ln,
            "elts": ["'"]
        })
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col += ": ".length,
            "stopLn": ln,
            "elts": [":"]
        })
        elts.push(visit(cx, node.expr))
        return node
        return {
            "tag": "tspan",
            "class": "literalField",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        } 
    }

    function virtualField(cx, node) {
        print("virtualField")
        let startCol = col
        let startLn = ln
        let elts = [ ]
        elts.push({
            "tag": "tspan",
            "class": "keyword",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": [ node.kind===1 ? "get" : "set" ]
        })
        col += ("get ").length
        elts.push(visit(cx, node.name))
        elts.push(visit(cx, node.func.func))  // FIXME remove intermediate literalfunction
        return node
        return {
            "tag": "tspan",
            "class": "virtualField",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        } 
    }

    function computedName(cx, node) {
        print("computedName")
        let startCol = col
        let startLn = ln
        let elts = [ ]
        elts.push(visit(cx, node.expr))
        return node
        return {
            "tag": "tspan",
            "class": "ComputedName",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        }
    }

    function arrayComprehension(cx, node) {
        print("arrayComprehension")
        let startCol = col
        let startLn = ln
        let elts = [ ]
        let tempCol = col
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["["]
        })
        col = tempCol + 2
        elts.push(visit(cx, node.expr))
        ln += 1
        col = tempCol + 2
        elts.push(visit(cx, node.forList))
        if (cx, node.ifCond) {
            col = tempCol + 2
            elts.push(visit(cx, node.ifCond))
        }
        ln += 1
        col = tempCol
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["]"]
        })
        col += ("]").length
        return node
        return {
            "tag": "tspan",
            "class": "ArrayComprehension",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        }
    }

    function comprehendFor(cx, node) {
        print("comprehendFor")
        let startCol = col
        let startLn = ln
        let elts = [ ]
        elts.push({
            "tag": "tspan",
            "class": "keyword",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["for"]
        })
        col += ("for ").length
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["("]
        })
        col += ("( ").length
        let tempCol = col
        elts.push(visit(cx, node.head))
        col = tempCol
        elts.push({
            "tag": "tspan",
            "class": "keyword",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["of"]
        })
        col += ("of ").length
        elts.push(visit(cx, node.iterator))
        col += 1 // space after iterator
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": [")"]
        })
        ln += 1
        col = tempCol - ("for ( ").length
        if (cx, node.subclause) {
            elts.push(visit(cx, node.subclause))
        }
        return node
        return {
            "tag": "tspan",
            "class": "comprehendFor",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        } 
    }

    function comprehendIf(cx, node) {
        print("comprehendIf")
        let startCol = col
        let startLn = ln
        let elts = [ ]
        elts.push({
            "tag": "tspan",
            "class": "keyword",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["if"]
        })
        col += ("if ").length
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": ["("]
        })
        col += ("(").length + 1
        elts.push(visit(cx, node.condition))
        col += 1
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": [")"]
        })
        return node
        return {
            "tag": "tspan",
            "class": "comprehendIf",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        } 
        ln += 1
    }

    function literalInt(cx, node) {
        print("literalInt col="+col)
        let n = {
            "tag": "tspan",
            "class": "LiteralInt",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": [node.intValue]
        }
        col += (String(cx, node.intValue)).length
        return n
    }

    function literalBoolean(cx, node) {
        print("literalBoolean")
        let n = {
            "tag": "tspan",
            "class": "LiteralBoolean",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": [ node.booleanValue ]
        }
        col += (String(cx, node.booleanValue)).length
        return n
    }

    function literalNull(cx, node) {
        print("literalNull")
        let n = {
            "tag": "tspan",
            "class": "LiteralNull",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": [ "null" ]
        }
        col += ("this").length
        return n
    }

    function thisExpr(cx, node) {
        print("thisExpr")
        let n = {
            "tag": "tspan",
            "class": "ThisExpr",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": [ "this" ]
        }
        col += ("this").length
        return n
    }

    function binaryOpText(op) {
        print("binaryOpText() op="+op)
        switch (op) {
        case Ast::plusOp:
            return "+"
        case Ast::minusOp:
            return "-"
        case Ast::timesOp:
            return "*"
        case Ast::divideOp:
            return "/"
        case Ast::remainderOp:
            return "%"
        case Ast::leftShiftOp:
            return "<<"
        case Ast::rightShiftOp:
            return ">>"
        case Ast::rightShiftUnsignedOp:
            return ">>>"
        case Ast::bitwiseAndOp:
            return "&"
        case Ast::bitwiseOrOp:
            return "|"
        case Ast::bitwiseXorOp:
            return "^"
        case Ast::logicalAndOp:
            return "&&"
        case Ast::logicalOrOp:
            return "||"
        case Ast::instanceOfOp:
            return "instanceof"
        case Ast::inOp:
            return "in"
        case Ast::equalOp:
            return "=="
        case Ast::notEqualOp:
            return "!="
        case Ast::strictEqualOp:
            return "==="
        case Ast::strictNotEqualOp:
            return "!=="
        case Ast::lessOp:
            return "<"
        case Ast::lessOrEqualOp:
            return "<="
        case Ast::greaterOp:
            return ">"
        case Ast::greaterOrEqualOp:
            return ">="
        case Ast::commaOp:
            return ","
        }
        throw "unhandled binary op: " + op;
    }

    function binaryExpr(cx, node) {
        print("binaryExpr")
        let startCol = col
        let startLn = ln
        let elts = [ ]
        let tempCol = col
        elts.push(visit(cx, node.e1))
        if (cx, node.op != Ast::commaOp) {
            col += 1
        }
        elts.push({
            "tag": "tspan",
            "class": "punc",
            "id": node.id,
            "startCol": col,
            "startLn": ln,
            "stopCol": col,
            "stopLn": ln,
            "elts": [binaryOpText(node.op)]
        })
        if (cx, node.op == Ast::logicalAndOp ||
            node.op == Ast::logicalOrOp ||
            node.op == Ast::commaOp) {
            ln += 1
            col = tempCol
        }
        else {
            col += binaryOpText(node.op).length + 1   // space after operator
        }
        elts.push(visit(cx, node.e2))
        return node
        return {
            "tag": "tspan",
            "class": "binaryExpr",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        } 
    }

    function unaryOpText(op) {
        switch (op) {
        case Ast::deleteOp:
            return "delete"
        case Ast::preIncrOp:
        case Ast::postIncrOp:
            return "++"
        case Ast::preDecrOp:
        case Ast::postDecrOp:
            return "--"
        case Ast::voidOp:
            return "void"
        case Ast::typeOfOp:
            return "typeof"
        case Ast::unaryPlusOp:
            return "+"
        case Ast::unaryMinusOp:
            return "-"
        case Ast::bitwiseNotOp:
            return "~"
        case Ast::logicalNotOp:
            return "!"
        case Ast::spreadOp:
            return "..."
        }
        throw "unhandled unary op: " + op;
    }

    function unaryExpr(cx, node) {
        print("unaryExpr")
        let startCol = col
        let startLn = ln
        let elts = [ ]
        if (cx, node.op == Ast::parenOp) {
            elts.push({
                "tag": "tspan",
                "class": "punc",
                "id": node.id,
                "startCol": col,
                "startLn": ln,
                "stopCol": col,
                "stopLn": ln,
                "elts": ["("]
            })
            col += "(".length
            elts.push(visit(cx, node.e1))
            elts.push({
                "tag": "tspan",
                "class": "punc",
                "id": node.id,
                "startCol": col,
                "startLn": ln,
                "stopCol": col,
                "stopLn": ln,
                "elts": [")"]
            })
            col += ")".length
        }
        else {
            if (cx, node.op != Ast::postIncrOp &&
                node.op != Ast::postDecrOp) {
                elts.push({
                    "tag": "tspan",
                    "class": "punc",
                    "id": node.id,
                    "startCol": col,
                    "startLn": ln,
                    "stopCol": col,
                    "stopLn": ln,
                    "elts": [unaryOpText(node.op)]
                })
                col += unaryOpText(node.op).length
                if (cx, node.op == Ast::deleteOp ||
                    node.op == Ast::voidOp ||
                    node.op == Ast::typeOfOp) {
                    col += 1   // space after operator
                }
            }
            elts.push(visit(cx, node.e1))
            if (cx, node.op == Ast::postIncrOp ||
                node.op == Ast::postDecrOp) {
                elts.push({
                    "tag": "tspan",
                    "class": "punc",
                    "id": node.id,
                    "startCol": col,
                    "startLn": ln,
                    "stopCol": col,
                    "stopLn": ln,
                    "elts": [unaryOpText(node.op)]
                })
                col += unaryOpText(node.op).length
            }
        }
        return node
        return {
            "tag": "tspan",
            "class": "unaryExpr",
            "id": node.id,
            "startCol": startCol,
            "startLn": startLn,
            "stopCol": col,
            "stopLn": ln,
            "elts": elts
        } 
    }

    function objectRef(cx, node) {
        print("objectRef")
        visit(cx, node.base)
        if (cx, node.ident.tag==="ComputedName") {
            visit(cx, node.ident)
        }
        else {
            visit(cx, node.ident)
        }
        return node
     }

     function stub(cx, node) {
        print("stub: " + node.tag)
        return node
     }
}